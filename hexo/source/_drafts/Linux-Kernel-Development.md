---
title: Linux Kernel Development
tags:
categories: 内核
---

* Linux 的进程调度是基于 "处理器比重" 策略，具体实现通过 vruntime 成员。所有进程以各自的 vruntime 作为 Key，链接成为一个 RBTree。调度核心通过查找最小的 vruntime 对应的进程，作为下一刻需要运行的进程。**vruntime 作为进程调度的核心，那它的计算方法是什么？**

* 应用程序进行系统调用(system call)时，通过 **软中断(soft irq)** 陷入内核态，将 **系统调用号** 以及 **参数指针** 通过 CPU **通用寄存器** 传入(exp. eax, ebx...)，由内核代表应用程序在 *内核空间* 执行系统调用。

* Linux 内核常用的 **内建数据结构** ： 链表 list， 队列 kfifo， 映射 idr， 二叉树 rbtree

* **Linux 中断实现机制怎样？** 中断发生时，通过 **中断向量表** 跳转到预定义入口点。初始入口点将 **中断号保存在栈中**，然后跳转调用 ```unsigned int do_IRQ(struct pt_regs regs)``` 进行处理。因为 C 的调用惯例是要把函数参数放在 **栈的顶部**，因此可以从 **pt_regs 结构中提取出中断号** 进行进一步处理。

* **什么是中断上下文？**当执行一个中断处理程序时，内核即处于中断上下文 (interrupt context) 中。

* **为什么中断里面不能休眠？** 因为没有后备进程，所以中断上下文不可以休眠，否则又怎能对它重新调度呢？ 这段话中的，**后备进程** 要怎么理解？ **中断栈又是什么鬼？**

* **为什么中断处理需要分成 上半部 和 下半部 ？**  **上半部分** 简单快速，执行的时候禁止一些或者全部中断。 **下半部分** 稍后执行，而且执行期间可以相应所有的中断。这种设计可使系统处于中断屏蔽状态的时间尽可能的短，以此来提高系统的相应能力。

* **softirq 和 sys_call 中的软中断意义是否一致？** 答案是：不一致！sys_call 中的软中断指的是 **体系结构** 预留的软中断，有固定的中断号，触发后 **立即** 经由中断向量表进行映射跳转；softirq 中的软中断仅仅是一种 **软件机制**，维护一组静态注册的回调函数列表，触发后 **无法立即** 回调处理函数，需等待时机 (硬中断代码返回、ksoftirqd 内核线程中、do_softirq 显示调用刷新)

* ** softirq 中为什么不能休眠？ ** 难道是 softirq 是处于中断上下文 interrupt context？

* **tasklet 和 工作队列 的主要区别？** tasklet 是 **基于 softirq 实现**，调用者将目标 tasklet 注册到 ```__this_cpu```（*更好利用处理器的高速缓存*）的 tasklet list 中，然后触发软中断等待执行，回调处理中 **不允许休眠**； 工作队列 是 **基于 内核线程kthread** 和 **等待队列 waitqueue** 实现，硬中断函数中唤醒对应内核线程，在线程函数中检查并遍历执行 worklist，回调处理中 **允许调度及休眠** 。

* **为什么全局变量自加操作，在多线程中是不安全的？** 请看以下例子：

|  线程 1       | 线程 2        |     | 线程 1       | 线程 2         |
|--------------|--------------|     |--------------|---------------|
| 获得 i (7)    | ------       |     | 获得 i (7)    | 获得 i (7)    |
| 增加 i (7->8) | ------       |     | 增加 i (7->8) | ------       |
| 写回 i (8)    | ------       |     | -------      | 增加 i (7->8) |
| ------       | 获得 i (8)    |     | 写回 i (8)    | ------       |
| ------       | 增加 i (8->9) |     | ------       | 写回 i (8)    |
| ------       | 写回 i (9)    |


* **造成并发执行的原因？为什么数据需要同步？**
  - Userspace： 用户程序在任何时刻都可能 **被调度程序抢占和重新调度**；
  - Userspace： 异步发生的 **信号** 处理（什么信号？）
  - Kernel： **中断** --- 几乎可以任何时刻异步发生
  - Kernel： **软中断和 tasklet** --- 内核能在 **任何时刻** 唤醒或调度 软中断 和 tasklet ( *怎么理解这里的任何时刻？具体是什么 Case 下？* )
  - Kernel： **内核抢占** --- 内核具有抢占性，内核中的任务可能会被另一任务抢占
  - Kernel： **睡眠及用户空间的同步** --- 内核执行的进程可能会睡眠，这就会 **唤醒调度程序**，从而导致调度一个新的用户进程执行
  - Kernel： **对称多处理器 SMP** --- 两个或多个处理器可以同时执行代码


* **在编写内核代码时，你要问自己下面这些问题：**
  - 这个数据是不是全局的？除了当前线程外，其他线程能不能访问它？
  - 这个数据会不会在 进程上下文 和 中断上下文 中共享？它是不是要在两个不同的中断处理程序中共享？
  - 进程在访问数据时可不可能被抢占？被调度的新程序会不会访问同一数据？
  - 当前进程是不是会休眠（阻塞）在某些资源上，如果是，它会让共享数据处于何种状态？
  - 怎样防止数据失控？
  - 如果这个函数又在另一个处理器上被调度将会发生什么呢？
  - 如何确保代码远离并发威胁呢？


* **常用的内核同步手段有哪些？简单介绍实现机制**
 - **atomic_t** 原子操作：由 **体系结构** 提供的原子操作简单算术指令实现（经典用途：计数器）

 - **spinlock** 自旋锁：忙循环 - 旋转 - 等待，自旋锁不应被长时间持有。( rwlock 读写自旋锁 )
  > 由于下半部可以抢占进程上下文中的代码，所以当下半部和进程上下文共享数据时，必须对进程上下文中的共享数据进行保护，所以需要加锁的同时还要 **禁止下半部执行 spin_lock_bh()**.
 >
 > 同样，由于中断处理程序可以抢占下半部，所以如果中断处理程序和下半部共享数据的话，那么就必须在获取恰当的锁的同时还要 **禁止中断 spin_lock_irqsave()**.

 - **semaphone** 信号量：基于等待队列实现的睡眠锁，适用于长时间持有的情况。( rwsem 读写信号量 & mutex 互斥信号量)
 > 函数 down_interruptible() 试图获取制定的信号量，如果信号量不可用，将把进程设置为 TASK_INTERRUPTIBLE 状态。而函数 down() 则会让进程在 TASK_UNINTERRUPTIBLE 状态下休眠，此状态无法响应其他信号了。所以 **使用 down_interruptible() 比使用 down() 更为普遍（也更正确）**

 - **completion** 完成变量：用于一个任务发出信号通知另一个任务发生了特定事件，实现思想和信号量一致。
