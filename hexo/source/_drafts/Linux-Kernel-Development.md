---
title: Linux Kernel Development
tags:
categories: 内核
---

* Linux 的进程调度是基于 "处理器比重" 策略，具体实现通过 vruntime 成员。所有进程以各自的 vruntime 作为 Key，链接成为一个 RBTree。调度核心通过查找最小的 vruntime 对应的进程，作为下一刻需要运行的进程。**vruntime 作为进程调度的核心，那它的计算方法是什么？**

* 应用程序进行系统调用(system call)时，通过 **软中断(soft irq)** 陷入内核态，将 **系统调用号** 以及 **参数指针** 通过 CPU **通用寄存器** 传入(exp. eax, ebx...)，由内核代表应用程序在 *内核空间* 执行系统调用。

* Linux 内核常用的 **内建数据结构** ： 链表 list， 队列 kfifo， 映射 idr， 二叉树 rbtree

* **Linux 中断实现机制怎样？** 中断发生时，通过 **中断向量表** 跳转到预定义入口点。初始入口点将 **中断号保存在栈中**，然后跳转调用 ```unsigned int do_IRQ(struct pt_regs regs)``` 进行处理。因为 C 的调用惯例是要把函数参数放在 **栈的顶部**，因此可以从 **pt_regs 结构中提取出中断号** 进行进一步处理。

* **什么是中断上下文？**当执行一个中断处理程序时，内核即处于中断上下文 (interrupt context) 中。

* **为什么中断里面不能休眠？** 因为没有后备进程，所以中断上下文不可以休眠，否则又怎能对它重新调度呢？ 这段话中的，**后备进程** 要怎么理解？ **中断栈又是什么鬼？**

* **为什么中断处理需要分成 上半部 和 下半部 ？**  **上半部分** 简单快速，执行的时候禁止一些或者全部中断。 **下半部分** 稍后执行，而且执行期间可以相应所有的中断。这种设计可使系统处于中断屏蔽状态的时间尽可能的短，以此来提高系统的相应能力。

* **softirq 和 sys_call 中的软中断意义是否一致？** 答案是：不一致！sys_call 中的软中断指的是 **体系结构** 预留的软中断，有固定的中断号，触发后 **立即** 经由中断向量表进行映射跳转；softirq 中的软中断仅仅是一种 **软件机制**，维护一组静态注册的回调函数列表，触发后 **无法立即** 回调处理函数，需等待时机 (硬中断代码返回、ksoftirqd 内核线程中、do_softirq 显示调用刷新)

* ** softirq 中为什么不能休眠？ ** 难道是 softirq 是处于中断上下文 interrupt context？

* **tasklet 和 工作队列 的主要区别？** tasklet 是 **基于 softirq 实现**，调用者将目标 tasklet 注册到 ```__this_cpu```（*更好利用处理器的高速缓存*）的 tasklet list 中，然后触发软中断等待执行，回调处理中 **不允许休眠**； 工作队列 是 **基于 内核线程kthread** 和 **等待队列 waitqueue** 实现，硬中断函数中唤醒对应内核线程，在线程函数中检查并遍历执行 worklist，回调处理中 **允许调度及休眠** 。
