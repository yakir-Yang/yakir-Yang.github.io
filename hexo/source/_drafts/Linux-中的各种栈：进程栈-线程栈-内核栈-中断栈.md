---
title: Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈
date: 2016-08-26 23:24:35
tags:
categories: 内核
---

## 栈是什么？栈有什么作用？
首先，栈 (stack) 是一种串列形式的 **数据结构**。这种数据结构的特点是 **后入先出** (LIFO, Last In First Out)，数据只能在串列的一端 (称为：栈顶 top) 进行 **推入** (push) 和 **弹出** (pop) 操作。根据栈的特点，很容易的想到可以利用数组，来实现这种数据结构。但是本文要讨论的并不是软件层面的栈，而是硬件层面的栈。

![栈结构](/images/kernel/stack/栈结构.png)

大多数的处理器架构，都有实现硬件栈。有专门的栈指针寄存器，以及特定的硬件指令来完成 入栈/出栈 的操作。例如在 ARM 架构上，R13 (SP) 指针是堆栈指针寄存器，而 PUSH 是用于压栈的汇编指令，POP 则是出栈的汇编指令。

> 扩展阅读：[ARM 寄存器简介](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204ic/Babefbce.html)
>
> ARM 处理器拥有 37 个寄存器。 这些寄存器按部分重叠组方式加以排列。 每个处理器模式都有一个不同的寄存器组。 编组的寄存器为处理处理器异常和特权操作提供了快速的上下文切换。
>
> 提供了下列寄存器：
> - 三十个 32 位通用寄存器：
>   - 存在十五个通用寄存器，它们分别是 r0-r12、sp、lr
>   - sp (r13) 是堆栈指针。C/C++ 编译器始终将 sp 用作堆栈指针
>   - lr (r14) 用于存储调用子例程时的返回地址。如果返回地址存储在堆栈上，则可将 lr 用作通用寄存器
> - 程序计数器 (pc)：指令寄存器
> - 应用程序状态寄存器 (APSR)：存放算术逻辑单元 (ALU) 状态标记的副本
> - 当前程序状态寄存器 (CPSR)：存放 APSR 标记，当前处理器模式，中断禁用标记等
> - 保存的程序状态寄存器 (SPSR)：当发生异常时，使用 SPSR 来存储 CPSR

上面是栈的原理和实现，下面我们来看看栈有什么作用。栈作用可以从两个方面体现：**函数调用** 和 **多任务切换** 。

### 一、函数调用

我们知道一个函数调用有以下三个基本过程：
- 调用参数的传入
- 局部变量的空间管理
- 函数返回

函数的调用必须是高效的，而数据存放在 **CPU通用寄存器** 或者 **RAM 内存** 中无疑是最好的选择。以传递调用参数为例，我们可以选择使用 CPU通用寄存器 来存放参数。但是通用寄存器的数目都是有限的，当出现函数嵌套调用时，子函数再次使用原有的通用寄存器必然会导致冲突。因此如果想用它来传递参数，那在调用子函数前，就必须先 **保存原有寄存器的值**，然后当子函数退出的时候再 **恢复原有寄存器的值** 。

函数的调用参数数目一般都相对少，因此通用寄存器是可以满足一定需求的。但是局部变量的数目和占用空间都是比较大的，再依赖有限的通用寄存器未免强人所难，因此我们可以采用某些 RAM 内存区域来存储局部变量。但是存储在哪里合适？既不能让函数嵌套调用的时候有冲突，又要注重效率。

这种情况下，栈无疑提供很好的解决办法。一、对于通用寄存器传参的冲突，我们可以再调用子函数前，将通用寄存器临时压入栈中；在子函数调用完毕后，在将已保存的寄存器再弹出恢复回来。二、而局部变量的空间申请，也只需要向下移动下栈顶指针；将栈顶指针向回移动，即可就可完成局部变量的空间释放；三、对于函数的返回，也只需要在调用子函数前，将返回地址压入栈中，待子函数调用结束后，将函数返回地址弹出给 PC 指针，即完成了函数调用的返回；于是上述函数调用的三个基本过程，就演变记录一个栈指针的过程。每次函数调用的时候，都配套一个栈指针。即使循环嵌套调用函数，只要对应函数栈指针是不同的，也不会出现冲突。

![函数栈结构](/images/kernel/stack/函数栈.png)


> 扩展阅读：[函数栈帧 (Stack Frame)](http://www.cnblogs.com/clover-toeic/p/3755401.html)
>
> 函数调用经常是嵌套的，在同一时刻，栈中会有多个函数的信息。每个未完成运行的函数占用一个独立的连续区域，称作栈帧(Stack Frame)。栈帧存放着函数参数，局部变量及恢复前一栈帧所需要的数据等，函数调用时入栈的顺序为：
>
> 实参N~1 → 主调函数返回地址 → 主调函数帧基指针EBP → 被调函数局部变量1~N
>
> 栈帧的边界由 **栈帧基地址指针 EBP** 和 **栈指针 ESP** 界定，EBP 指向当前栈帧底部(高地址)，在当前栈帧内位置固定；ESP指向当前栈帧顶部(低地址)，当程序执行时ESP会随着数据的入栈和出栈而移动。因此函数中对大部分数据的访问都基于EBP进行。函数调用栈的典型内存布局如下图所示：
>
> ![函数栈结构](/images/kernel/stack/函数调用栈的典型内存布局.png)


### 二、多任务切换





-------
## Linux 中有几种栈？为什么需要区分这些栈？

-------
## Linux 各种栈的内存位置？以及对应的内核实现？

-------
## Reference
[C语言函数调用栈(一)](http://www.cnblogs.com/clover-toeic/p/3755401.html)

[栈的作用](http://www.cnblogs.com/scnutiger/articles/3770991.html)

[对Linux的进程内核栈的认识](http://blog.chinaunix.net/uid-20543672-id-2996319.html)

[Linux 进程栈和线程栈的区别](http://blog.csdn.net/daniel_ice/article/details/8146003)

[Linux中的栈：用户态栈/内核栈/中断栈](http://blog.chinaunix.net/uid-14528823-id-4136760.html)

[函数调用栈 剖析＋图解](http://blog.csdn.net/wangyezi19930928/article/details/16921927)
