---
title: Linux 中的各种栈：进程栈-线程栈-内核栈-中断栈
tags:
categories: 内核
---

## 栈是什么？栈有什么作用？
首先，栈 (stack) 是一种串列形式的 **数据结构**。这种数据结构的特点是 **后入先出** (LIFO, Last In First Out)，数据只能在串列的一端 (称为：栈顶 top) 进行 **推入** (push) 和 **弹出** (pop) 操作。根据栈的特点，很容易的想到可以利用数组，来实现这种数据结构。但是本文要讨论的并不是软件层面的栈，而是硬件层面的栈。

大多数的处理器架构，都有实现硬件栈。有专门的栈指针寄存器，以及特定的硬件指令来完成 入栈/出栈 的操作。例如在 ARM 架构上，R13 (SP) 指针是堆栈指针寄存器，而 PUSH 是用于压栈的汇编指令，POP 则是出栈的汇编指令。

> 扩展阅读：[ARM 寄存器简介](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204ic/Babefbce.html)

> ARM 处理器拥有 37 个寄存器。 这些寄存器按部分重叠组方式加以排列。 每个处理器模式都有一个不同的寄存器组。 编组的寄存器为处理处理器异常和特权操作提供了快速的上下文切换。
>
> 提供了下列寄存器：
  - 三十个 32 位通用寄存器：
    - 存在十五个通用寄存器，它们分别是 r0-r12、sp、lr
    - sp (r13) 是堆栈指针。C/C++ 编译器始终将 sp 用作堆栈指针
    - lr (r14) 用于存储调用子例程时的返回地址。如果返回地址存储在堆栈上，则可将 lr 用作通用寄存器
  - 程序计数器 (pc)：指令寄存器
  - 应用程序状态寄存器 (APSR)：存放算术逻辑单元 (ALU) 状态标记的副本
  - 当前程序状态寄存器 (CPSR)：存放 APSR 标记，当前处理器模式，中断禁用标记等
  - 保存的程序状态寄存器 (SPSR)：当发生异常时，使用 SPSR 来存储 CPSR

上面是栈的原理和实现，下面我们来看看栈有什么作用。栈作用可以从两个方面体现：**函数调用** 和 **多任务切换** 。

我们知道一个函数有以下三个大问题：
- 调用参数的传入
- 局部变量的空间管理
- 函数返回

*调用参数的传入*：传递参数的目的，是为了代码可以重用。函数的调用必须是高效率的，而数据存放在 **CPU通用寄存器** 无非是最快的形式。但是寄存器的数目都是有限的，当存在函数嵌套调用的时候，再使用原有的寄存器必然会有冲突。因此如果想用它来传递参数，那在调用子函数前，就必须先把寄存器的值 **保存** 起来，然后当子函数退出的时候再 **恢复** 原有寄存器的值。

*局部变量*：局部变量


、 **RAM 内存**；

-------
## Linux 中有几种栈？为什么需要区分这些栈？

-------
## Linux 各种栈的内存位置？以及对应的内核实现？

-------
## Reference
[C语言函数调用栈(一)](http://www.cnblogs.com/clover-toeic/p/3755401.html)

[栈的作用](http://m.blog.csdn.net/article/details?id=51598185)

[对Linux的进程内核栈的认识](http://blog.chinaunix.net/uid-20543672-id-2996319.html)

[Linux 进程栈和线程栈的区别](http://blog.csdn.net/daniel_ice/article/details/8146003)

[Linux中的栈：用户态栈/内核栈/中断栈](http://blog.chinaunix.net/uid-14528823-id-4136760.html)

[函数调用栈 剖析＋图解](http://blog.csdn.net/wangyezi19930928/article/details/16921927)
